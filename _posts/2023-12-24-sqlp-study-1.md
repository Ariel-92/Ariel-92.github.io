---
title: SQLP 스터디 자료 1
author: Ariel
date: 2023-12-24 23:00:00 +0900
categories: [Study, SQL, SQLP]
tags: [SQL]
---
이 포스트는 '친절한 SQL 튜닝' 책을 기반으로 한 스터디 자료입니다.
---
# 인덱스 구조 및 탐색
## 인덱스 튜닝이란
> 인댁스는 데이터베이스에서 데이터를 찾는 방법 중 하나이며, 인덱스를 이용해 적은 비용으로 데이터를 탐색할 수 있도록 최적화 하는 것을 인덱스 튜닝이라 한다.

### 데이터베이스에서 데이터를 탐색하는 방법
1. 테이블 풀 스캔
   * 전체 테이블을 처음부터 끝까지 모두 읽어서 탐색하는 방법이다.
   * 전체 데이터에 접근해야 하는 배치 등의 경우에 유용하나 소량의 데이터를 자주 호출하는 온라인 트랜잭션에서는 효율성이 떨어진다.
2. 인덱스 스캔
   * 미리 만들어둔 인덱스를 이용하여 데이터를 탐색하는 방법이다.
   * 자주 탐색하는 조건에 따라 데이터를 미리 정렬한 인덱스 테이블에서 데이터를 탐색하여 온라인 트랜잭션에서 효율적인 사용이 가능하다.
   * 데이터에 직접 접근하기 위해서는 랜덤I/O를 한단계 더 거쳐 데이터에 접근해야하기 때문에 탐색하는 데이터가 대량인 경우 테이블 풀 스캔보다 일반적으로 효율이 떨어진다.
### SQL 튜닝은 랜덤I/O와의 전쟁
데이터베이스의 성능을 좌우하는 건 결국 느린 디스크 I/O를 얼마나 효율적으로 제어하는가에 달려있다.<br/>
그 중에서도 OLTP에서 많이 사용하는 랜덤 I/O를 얼마나 개선하느냐가 중요하다. 
## 인덱스 구조
![인덱스 예제](https://github.com/Ariel-92/Ariel-92.github.io/assets/71688847/7c60ca64-911f-4664-9679-41cc814256d8)
> 인덱스는 일반적으로 B*Tree 인덱스를 사용한다

인덱스는 트리 구조로 구성되며, 항상 키 값 순으로 정렬돼 있다.<br>
LMC는 'Leftmost Child'의 줄임말으로 가장 왼쪽에 있는 첫번째 값을 의미한다.<br>
각 블록에는 상위의 Root 또는 Branch의 값을 범위의 기준으로 하여 정렬한 데이터를 저장하며, 리프 블록에 저장된 레코드는 ROWID를 갖는다.<br>
* ROWID = 데이터 블록 주소 + 로우 번호
* 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
* 블록 번호 : 데이터파일 내에서 부여한 사대적 순번
* 로우 번호 : 블록 내 순번

## 인덱스 탐색
> 인덱스 탐색은 수직적 탐색과 수평적 탐색이 있다

1. 수직적 탐색
  * 수직적 탐색은 트리의 위에서 아래로 탐색해 나가는 과정을 말한다 
  * 위의 그림에서 송아랑을 찾는다고 하면 서 보다 큰 값 > 서지혁보다 크고 최지우 보다 작은 값 > 블록 내 첫 번째 송아랑
  * 수직적 탁색은 조건을 만족하는 레코드를 찾는게 아닌 조건을 만족하는 '첫 번째 레코드'를 찾는 과정이다.
2. 수평적 탐색
  * 수직적 탐색을 통해 스캔 시작점을 찾았으면 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔한다.
  * 위의 그림에서는 송아랑이 한명 뿐이므로 한 건의 데이터를 조회한 뒤 심재혁이 나와 탐색을 바로 종료한다.

# 인덱스 기본 사용법
> 인덱스의 기본 사용법은 인덱스를 Range Scan 하는 방법을 의미한다.

### 인덱스를 사용한다?
<img alt="도서 색인 예제 그림" src="https://github.com/Ariel-92/Ariel-92.github.io/assets/71688847/09a3c83c-82f1-42f8-8f6a-3c734ebd6edf" width="1200">

데이터베이스에서 인덱스를 사용한다는 건 책 뒤편의 색인에서 원하는 단어가 있는 페이지를 찾는 것과 비슷하다. 우리는 Amazon Giveaway를 위의 
색인에서 찾을 때에 A > Amazon을 찾고 같은 Amazon으로 시작하는 단어들을 순서대로 살펴 Amazon Giveaway를 빠르게 찾을 수 있다.<br>
앞의 과정이 수직적 탐색이고 뒤의 과정이 수평적 탐색이라고 해도 전혀 다를 바 없다.

### Index Range Scan을 사용할 수 없는 경우
Index Range Scan은 기본적으로 Index 키 값들이 정렬된 상태를 이용하여 범위 탐색을 하게 되어있다. 이 때 정렬은 키의 순서에 따라 이루어지며, 키 값이 아닌 다른 값들은 정렬이 되어있지 않은 상태이다.<br>
그렇기 때문에 아래와 같은 경우 Index Range Scan이 이루어지지 못해 Index Full Scan 또는 Table Full Scan이 발생한다.

1. LIKE 조건절을 이용하여 후미 또는 중간 값으로 탐색하는 경우
2. 데이터를 형변환, 합, 평균등 조작하여 탐색하는 경우
3. 인덱스 키가 1, 2, 3 이 있는 경우에 1은 조건절에서 제외하고 2만 넣는 경우와 같이 앞의 키가 조건절에서 제외되는 경우

모두 인덱스의 정렬데이터와 다른 값 또는 기준을 이용하여 탐색을 하는 경우로 이루어져 있음을 알 수 있다.

### Index Range Scan을 사용했을 때 쿼리의 효율이 좋아지는 이유
Index Range Scan을 사용하는 경우 쿼리의 효율은 단건을 찾거나, 범위 탐색을 할 때에도 물론 좋은 효율을 내지만, 데이터가 정렬된 상태를 이용할 때에
가장 좋은 효과를 얻을 수 있다.<br>
Sort와 Order By는 레코드를 특정 컬럼들을 기준으로 정렬하게 하는데 이 때 그 컬럼들의 기준이 인덱스 컬럼과 같다면 쿼리 실행 시 정렬 연산을 하지 않고 바로 데이터를 사용할 수 있다.<br>
MIN, MAX의 경우는 인덱스를 사용하는 경우 맨 앞의 값 또는 맨 뒤의 값을 꺼내오면 되기 때문에 인덱스를 사용하는 경우 매우 빠르게 값을 얻을 수 있다. 다만 형변환이나 형태를 변형하여 출력을 해야할 때에는 값을 먼저 찾고 수정이 이루어지도록 쿼리를 짜야한다.<br>
또한 옵티마이저는 자동형변환 기능을 제공하고 있는데, 종종 부적절한 형변환이 이루어지므로 항상 정확한 자료형을 이용하는 것이 좋다.


# 인덱스 확장기능 사용법
> 인덱스 스캔 방식은 Index Range Scan 외에도 몇가지 방법이 있다. 주요 특징을 정리해보자

1. Index Range Scan
  * 앞에서 학습한 방법으로 인덱스 루트에서 리프 블록까지 수직적으로 탐색한 후에 '필요한 범위(Range)'만 스캔한다.
2. Index Full Scan
  * 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방법이다.
  * 최적의 인덱스가 없을 때 차선으로 사용하는 방법이며, TABLE이 거대하여 TABLE 직접 접근하는 것보다 속도에 이점이 있는 경우에 사용한다.
3. Index Unique Scan
  * 수직적 탐색만으로 데이터를 찾는 스캔 방법으로 Unique 인덱스를 '=' 조건으로 탐색하는 경우에 작동한다.
4. Index Skip Sacn
  * 인덱스 선두 컬럼이 조건절에서 빠졌을 때 사용하는 방법으로 오라클 9i 버전에서 선보여졌다.
  * 선두 컬럼이 빠져 정확하게 한 영역만 탐색할 순 없지만 조건절에서 사용하는 인덱스 들을 이용하여 인덱스 테이블의 일부 영역만 스캔하여 일부 영역을 건너뛰어가며 스캔하는 방법이다.
  * 인덱스 컬럼이 이름, 연봉 순서로 되어있을 때 연봉이 3000만원 이상 5000만원 이하인 경우를 검색한 경우 같은 이름인 경우 해당 연봉 범위만 탐색하고 건너 뛰는 것을 볼 수 있다.
  * 최선의 방법이 아니며 항상 효율적으로 작동한다는 보장이 되지 않으므로 가능한 인덱스를 조정하여 Index Range Scan을 사용할 수 있게 하는 것이 좋다.
5. Index Fast Full Scan
  * Index Full Scan보다 빠르게 작동한다.
  * 빠르게 탐색을 마칠 수 있는 이유는 논리적인 인덱스 트리 구조를 무시하고 병렬적으로 접근하여 한 번에 여러개의 데이터를 스캔할 수 있기 때문이다.
  * 대신 논리적인 구조를 무시하고 병렬 접근을 했기 때문에 결과 집합에서 인덱스에 따른 정렬된 값을 기대할 수 없다.
  * 빠른 속도로 사용하기 위해 Table에 직접 접근하는 Random I/O를 제외했기 때문에 인덱스에 포함된 컬럼으로만 조회할 때 사용 가능하다.
6. Index Range Scan Descending
  * Index Range Scan을 앞에서 부터가 아닌 뒤에서 부터 하는 형태이다.
  * Index Range Scan이 오름차순이었다면 Index Range Scan Descending은 내림차순으로 정렬된 결과집합을 얻게 된다.
