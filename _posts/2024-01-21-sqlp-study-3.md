---
title: SQLP 스터디 자료 3
author: Ariel
date: 2024-01-20 22:15:00 +0900
categories: [Study, SQL, SQLP]
tags: [SQL]
---
이 포스트는 '친절한 SQL 튜닝' 책을 기반으로 한 스터디 자료입니다.
---
# DML 튜닝

## Direct Path I/O 활용
> OLTP 환경은 자주 조회하는 데이터를 반복적으로 읽는 경우가 많기 때문에 버퍼 캐시가 성능 향상에 도움이 된다.
> 반면, 배치, 통계 프로그램 등에서 사용하는 SQL 데이터는 주로 대량 데이터를 처리하기 때문에 버퍼캐시를 경유하는 I/O 메커니즘이 되려 성능을 저하시킬 수 있다.
> Direct Path I/O는 버퍼 캐시를 경유하지 않고 곧바로 데이터 블록일 읽고 쓸 수 있게 제공하는 Oracle의 기능이다.

### Direct Path I/O
일반적인 블록 I/O의 경우 버퍼 캐시를 경유한다. 즉, 읽고자 하는 데이터가 버퍼 캐시에 있는지 먼저 찾아보고, 없는 경우에만 디스크에서 데이터를 조회한다.<br>
OLTP 환경과 같이 일부 데이터를 자주 조회하는 경우 버퍼 캐시를 이용할 때 성능 향상에 큰 도움이 되지만, 대량 데이터를 조회하는 환경에서는 버퍼캐시에 해당 데이터가 없는 경우가 더 많아 성능이 되려 저하될 가능성이 높다.<br>
대량 블록을 건건이 디스크로부터 버퍼캐시에 적재하고서 읽어야 하는 것도 부담이 크다. 그래서 오라클은 버퍼캐시를 경유하지 않고 곧바로 데이터 블록에 접근할 수 있도록 Direct Path I/O 기능을 제공한다. <br>
아래의 경우에 그 기능이 작동한다.
1. 병렬 쿼리로 Full Scan을 수행할 때
2. 병렬 DML을 수행할 때
3. Direct Path Insert를 수행할 때
4. Temp 세그먼트 블록들을 읽고 쓸 때
5. direct 옵션을 지정하고 export를 수행할 때
6. nocache 옵션을 지정한 LOB 컬럼을 읽을 때

### Direct Path Insert
일반적인 INSERT가 느린 이유는 아래와 같다.
1. 데이터를 입력할 수 있는 블록을 Freelist에서 찾는다. 테이블 HWM(High-Water-Mark) 아래쪽에 있는 블록 중 데이터 입력이 가능한(여유 공간이 있는) 블록을 목록으로 관리하는데, 이를 'Freelist'라고 한다.
2. Freelist에서 할당받은 블록을 버퍼캐시에서 찾는다.
3. 버퍼캐시에 없으면, 데이터파일에서 읽어 버퍼캐시에 적재한다.
4. INSERT 내용을 Undo 세그먼트에 기록한다.
5. INSERT 내용을 Redo 로그에 기록한다.

Direct Path Insert 방식을 사용하면, 대량데이터를 일반적인 INSERT 보다 훨씬 더 빠르게 입력할 수 있다.<br>
빠른 이유는 아래와 같다.
1. Freelist를 참조하지 않고 HWM 바깥 영역에 데이터를 순차적으로 입력한다.
2. 블록을 버퍼캐시에서 탐색하지 않는다.
3. 버퍼캐시에 적재하지 않고, 데이터파일에 직접 기록한다.
4. Undo 로깅을 안 한다.
5. Redo 로깅을 안 하게 할 수 있다. 테이블을 nologging 모드로 전환한 상태에서 Direct Path Insert 하면 된다.

> Direct Path Insert가 아닌 일반 INSERT 문을 로깅하지 않게 하는 방법은 없다.

Direct Path Insert를 사용할 때 주의할 점
1. 성능이 빨라지지만 Exclusive 모드 TM Lock이 걸린다. 따라서 커밋하기 전까지 다른 트랜잭션은 해당 테이블에 DML 수행이 불가능하다.
2. Freelist를 조회하지 않고 HWM 바깥 영역에 입력하므로 테이블에 여유 공간이 있어도 재활용 하지 않는다. 때문에 이 방식으로 데이터를 삭제하고 추가하는 경우, 데이터를 삭제한 만큼 공간을 덜 사용하지 않고 계속 사이즈가 늘어난다.

### 병렬 DML
INSERT는 append 힌트를 이용해 Direct Path Write 방식으로 유도할 수 있지만, UPDATE DELETE는 기본적으로 불가능하다.<br>
유일한 사용방법은 병렬 DML로 사용하는 것이다.

아래와 같이 병렬 DML을 활성화 해야한다.
```
alter session enable parallel dml;
```
그 뒤에 각 DML 문에 parallel 힌트를 사용하면 대상 레코드를 찾는 작업과 추가, 변경, 삭제 등의 작업도 병렬로 진행한다.<br>
12c 버전부터는 enable_parallel_dml 힌드도 지원한다.

## Lock과 트랜잭션 동시성 제어
> Lock은 데이터베이스의 특징을 결정짓는 가장 핵심적인 메커니즘이다.

### 오라클 Lock
오라클은 공유 리소스와 사용자 데이터를 보호할 목적으로 DML Lock, DDL Lock, 래치, 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 사용한다.<br>
애플리케이션 개발 측면에서 가장 중요하게 다루어야할 Lock은 무엇보다 DML Lock이다.

#### DML 로우 Lcok
DML 로우 Lock은 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지한다. 하나의 로우를 변경하려면 로우 Lock을 먼저 설정해야 한다.<br>
모든 DBMS는 DML 로우 Lock에 배타적 모드를 사용하므로 UPDATE 또는 DELETE를 진행 중인 로우를 다른 트랜잭션이 UPDATE하거나 DELETE 할 수 없다.<br>
INSERT에 대한 로우 Lock 경합은 Unique 인덱스가 있는 경우에만 발생한다. Unique 인덱스가 없는 경우 로우 Lock 경합은 발생하지 않는다.<br>
MVCC 모델을 활용하는 오라클은 SELECT 문에 로우 Lock을 사용하지 않는다. 오라클은 다른 트랜잭션이 변경한 로우를 읽을 때 복사본 블록을 만들어서 쿼리가 '시작된 시점'으로 되돌려 읽는다.
MVCC 모델을 사용하지 않는 DBMS는 SELECT 문에 공유 Lock을 사용하는데, 공유 Lock 끼리는 호환이 되며, 공유 Lock과 배타적 Lock은 호환이 되지 않아 DML과 SELECT가 서로 진행을 방해할 수 있다.

#### DML 테이블 Lock
오라클은 DML 로우 Lock을 설정하기에 앞서 테이블 Lock을 먼저 설정한다. 현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 막기 위함이다.
테이블 Lock을 TM Lock이라고도 부른다.<br>
오라클은 로우 Lock에 배타적 모드를 사용하지만, 테이블 Lock에는 여러가지 Lock 모드를 사용한다. 각 모드 및 모드간 호환성은 아래와 같다.('O' 표시는 두 모드 간 호환성이 있음을 의미)

|        | NULL  | RS  | RX  |  S  | SRX  |  X  |
|:------:|:-----:|:---:|:---:|:---:|:----:|:---:|
|  NULL  |   O   |  O  |  O  |  O  |  O   |  O  |
|   RS   |   O   |  O  |  O  |  O  |  O   |     |
|   RX   |   O   |  O  |  O  |     |      |     |
|   S    |   O   |  O  |     |  O  |      |     |
|  SRX   |   O   |  O  |     |     |      |     |
|   X    |   O   |     |     |     |      |     |

* RS : row share(or SS: sub share)
* RX : row exclusive(or SX: sub exclusive)
* S : share
* SRX : share row exclusive(or SSX: share/sub exclusive)
* X : exclusive

선행 트랜잭션과 호환되지 않는 모드로 테이블 Lock을 설정하려는 후행 트랜잭션은 대기하거나 작업을 포기해야 한다.
오라클에서 말하는 테이블 Lock은 현재 어떤 작업을 수행 중인지를 알리는 일종의 푯말이다. 
테이블 전체를 Lock을 걸어 다른 작업을 할 수 없게 막는게 아닌, 현재 수행중인 작업에 따라 Lock 모드를 결정하고, 후행 작업의 Lock 모드에 따라 작업의 범위가 결정된다.

#### Lock을 푸는 열쇠, 커밋
* 블로킹(blocking) : 선행 트랜잭션이 설정한 Lock 때문에 후행 트랜잭션이 작업을 진행하지 못하고 멈춰 있는 상태. 이 것을 해소하는 방법은 커밋 뿐이다.
* 교착상태(deadlock) : 두 트랜잭션이 각각 특정 리소스에 Lock을 설정한 상태에서 맞은편 트랜잭션이 Lock을 설정한 리소스에 또 Lock을 설정하려고 진행하는 상황. 둘 중 하나가 뒤로 물러나지 않으면 풀 수 없다.
  * 오라클에서는 교착상태가 발생하면 이를 먼저 인지한 트랜잭션이 문장 수준 롤백을 진행한 후 에러 메시지를 던진다. 교착 상태를 발생시킨 문장 하나만 롤백한다.
  * 이 때 교착상태는 해소되지만 블로킹이 발생한다.
  * 이 에러에 대해 예외처리를 하지 않으면 대기상태를 지속하게 되므로 주의해야 한다.

오라클에서는 데이터를 읽을 때 Lock을 사용하지 않아 다른 DBMS에 비해 상대적으로 Lock 경합이 적게 발생한다.<br>
그러므로 트랜잭션에 부담이 줄어 트랜잭션을 길게 가져갈 수 있는데, 이 때 너무 길게하면 트랜잭션 롤백이 오래 걸리거나 Undo 세그먼트 고갈 또는 경합이 발생할 수 있다. 그러므로 적절한 시점에 커밋을 해야한다.<br>
반대로 너무 자주 커밋을 하게 되면 서버 프로세스가 LGWR에게 로그 버퍼를 비우도록 요청하고 동기 방식으로 기다리는 횟수가 늘어 성능이 느려진다. 이런 경우 오라클 10gR2부터 제공하는 비동기식 커밋을 사용하는 방법도 고려해볼 수 있다.

* WAIT(default) : LGWR가 로그버퍼를 파일에 기록했다는 완료 메시지를 받을 때까지 기다린다(동기식 커밋).
* NOWAIT : LGWR의 완료 메시지를 기다리지 않고 바로 다음 트랜잭션을 진행한다(비동기식 커밋).
* IMMEDIATE(default) : 커밋 명령을 받을 때마다 LGWR가 로그버퍼를 파일에 기록한다.
* BATCH : 세션 내부에 트랜잭션 데이터를 일정량 버퍼링했다가 일괄 처리한다.

### 트랜잭션 동시성 제어
> 동시성 제어는 비관적 동시성 제어와 낙관적 동시성 제어로 나뉜다.

#### 비관적 동시성 제어
비관적 동시성 제어는 사용자들이 같은 데이터를 동시에 수정할 것으로 가정한다. 따라서 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회 또는 갱신처리가 완료될 때까지 이를 유지한다.<br>
비관적 동시성 제어는 자칫 시스템 동시성을 심각하게 떨어트릴 우려가 있지만, FOR UPDATE에 WAIT 또는 NOWAIT 옵션을 함께 사용하면 Lock을 얻기 위해 무한정 기다리지 않아도 되며, 이를 이용해 Exception을 발생시켜 오류메시지를 출력하면서 트랜잭션을 종료하는 방법등으로 동시성을 증가시킬 수도 있다.

#### 낙관적 동시성 제어
낙관적 동시성 제어는 사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정한다. 따라서 데이터를 읽을 때 Lock을 설정하지 않는다.
낙관적 동시성 제어에서도 UPDATE 전에 SELECT 문을 한 번 더 수행함으로써 Lock에 대한 예외처리를 하면 다른 트랜잭션이 설정한 Lock을 기다리지 않게 구현할 수 있다.

#### 동시성 제어 없는 낙관적 프로그래밍
낙관적 동시성 제어를 사용하면 Lock이 유지되는 시간이 매우 짧아져 동시성을 높이는데 매우 유리하다. 하지만 다른 사용자가 데이터를 변경했는지 검사하고 그에 따라 처리 방향성을 결정하는 번거로운 절차를 거쳐야한다.<br>
번거로움을 이유로 동시성 제어가 없는 낙관전 프로그래밍을 하는 경우 데이터가 잘못 갱신되는 경우가 발생할 수 있다. 이는 서비스에 크리티컬한 문제가 발생할 수 있으므로 번거롭더라도 정확하게 처리하여야한다.

### 채번 방식에 따른 INSERT 성능 비교
> INSERT, UPDATE, DELETE, MERGE 중 가장 중요하고 튜닝 요소가 많은 것은 INSERT다. 수행빋도가 가장 높기도 하지만, 채번 방식에 따른 성능 차이가 매우 크기 때문이다.

#### 채번 테이블
각 테이블 식별자의 단일컬럼 일련번호 또는 구분 속성별 순번을 채번하기 위해 별도 테이블을 관리하는 방식이다.<br>
이 방식은 채번 레코드를 변경하는 과정에 자연스럽게 액세스 직렬화가 이루어져 두 트랜잭션이 중복 값을 채번할 가능성을 방지한다.<br>
이 방식의 장점은 아래와 같다.
* 범용성이 좋다.
* INSERT 과정에 중복 레코드 발생에 대비한 예외 처리에 크게 신경쓰지 않아도 되므로 채번 함수만 잘 정의하면 편리하게 사용할 수 있다.
* INSERT 과정에 결변을 방지할 수 있다.
* PK가 복합컬럼일 때도 사용할 수 있다.

단점으로는 다른 채번 방식에 비해 성능이 안좋다. 채번 레코드를 변경하기 위한 로우 Lock 경합이 발생하기 때문이다. 로우 Lock은 기본적으로 대상 테이블에 INSERT를 마치고 커밋 또는 롤백할 때까지 유지된다.
동시 INSERT가 많은 경우 테이블 블록 자체에도 경합이 발생한다. 서로 다른 레코드를 변경하는 프로세스까지 경합하는 경우가 발생할 수 있다.
따라서, INSERT가 매우 잦은 테이블에는 이 방식을 사용할 수 없다.

#### 시퀀스 오브젝트
가장 큰 장점은 성능이 매우 빠르다. 채번 테이블과 마찬가지로 중복 레코드 발생에 대비한 예외처리에 크게 신경 쓰지 않아도 된다.<br>
성능이 장점이지만 시퀀스 채번 과정에서 Lock이 발생하므로 성능 이슈가 발생할 수 있다. 시퀀스 오브젝트도 오라클 내부에서 관리하는 채번 테이블이기 때문이다.<br>
결과적으로, 시퀀스 오브젝트도 결국 테이블이므로 값을 읽고 변경할 때 Lock이 발생할 수 있다.<br>
단점은 아래와 같다.
* '기본적으로' PK가 단일 컬럼인 경우에만 사용 가능하다는 점이다. 복합컬럼인 경우도 사용할 수는 있지만, 각 레코드를 유일하게 식볋하는 최소 컬럼으로 PK를 구성해야 한다는 최소성 요건을 위배하게 된다.
* 신규 데이터를 입력하는 과정에 결번이 생길 수 있다. 원인은 채번 이후 롤백을 하거나 CACHE 옵션을 설정한 시퀀스가 캐시에서 밀려나는 경우다.
  * 하지만 일련번호에 결번이 생기는 걸 꼭 막아야하는 것은 아니다. 데이터를 삭제하면서 생기는 결번은 막을 수 없다.

#### MAX + 1 조회
대상 테이블의 최종 일련번호를 조회하고, 거기에 1을 더해서 INSERT 하는 방식이다.
이 방식의 장점은 아래와 같다.
* 시퀀스 또는 별도의 채번 테이블을 관리하는 부담이 없다.
* 동시 트랜잭션에 의한 충돌이 많지 않으면 성능이 매우 빠르다
* 복합컬럼인 경우에도 사용 가능하다. 오히려 값의 수가 많을수록 성능이 좋아진다.

단점은 아래와 같다.
* 레코드 중복에 대비한 세밀한 예외처리가 필요하다
* 다중 트랜잭션에 의한 동시 채번이 심하면 시퀀스보다 성능이 많이 나빠질 수 있다. 레코드 중복으로 인한 로우 Lock 경합 때문이다.

<img src="https://github.com/Ariel-92/Ariel-92.github.io/assets/71688847/14c6475a-8812-4660-bcca-3546f13bd741" alt="Lock 경합 요소를 고려한 채번 방식 선택 기준">

#### 시퀀스보다 좋은 솔루션
한개 이상의 구분 속성과 함께 뒤쪽에 순번 대신 입력일시를 두는 방식으로 PK 구조를 설계하면, 채번 또는 INSERT 과정에 생기는 Lock 이슈를 거의 해소할 수 있다. 
또한 파티셔닝, 파티셔닝을 이용한 대량 DELETE 등에서 입력일시를 PK로 두는 경우 성능 향상에 큰 도움이 된다.

#### 인덱스 블록 경합
INSERT 성능이 너무 빠른 경우 인덱스 경합이 발생할 수 있음에 주의해야한다.채번 테이블 로우 Lock이나 시퀀스 Lock이 적용된 경우 잘 안 나타나지만 위의 경우 처럼 채번 과정을 생략하는 순간부터 인덱스 블록 경합이 발생할 수 있다. MAX + 1 방식에서도 자주 나타난다.<br>
인덱스 블록 경합을 해소하는 가장 일반적인 방법은 인덱스를 해시 파티셔닝 하는 것이다. 인덱스를 해시 파티셔닝하면 값이 순차적으로 증가하더라도 해시 함수가 리턴한 값에 따라 서로 다른 파티션에 입력되어 경합을 줄일 수 있다. 인덱스를 리버스 키 인덱스로 전환하는 방법도 고려할 수 있다.
