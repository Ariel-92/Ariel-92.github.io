---
title: SQLP 스터디 자료 2
author: Ariel
date: 2024-01-08 23:09:00 +0900
categories: [Study, SQL, SQLP]
tags: [SQL]
---
이 포스트는 '친절한 SQL 튜닝' 책을 기반으로 한 스터디 자료입니다.
---
# 조인튜닝

## NL(Nested Loop) 조인
>NL 조인은 인덱스를 이용한 조인으로, 가장 기본적이고, 자주 사용하는 조인 방법이다.

### 기본 메커니즘
NL 조인은 중첩 반복문(Nested Loop)을 이용하여 조건을 건건히 조회하여 조인 조건이 일치하는 레코드를 각 테이블에서 찾아 조인하는 방법이다.<br>
일반적으로 NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용한다. Outer 테이블의 크기가 매우 작은 경우(한 블록 정도의)에는 Outer테이블은 인덱스를 사용하지 않는 경우도 있다.<br>
Inner 테이블은 크기와 상관없이 항상 인덱스를 사용하는데, 인덱스를 사용하지 않는 경우에는 항상 테이블 내 모든 레코드를 조회하여 Outer 루프에서 읽은 건수만큼 Table Full Scan을 반복하기 때문이다.

### 실행계획 제어
NL 조인은 실해예획에서 NESTED LOOPS로 나타나는 것을 확인할 수 있다.<br>
NL 조인과 관련하여 아래와 같은 제어문을 사용할 수 있다.
* use_nl
  * NL 조인을 사용하라고 하는 힌트다.
  * ex) /*+ use_nl(B) */ *
* ordered
  * 조인 할 때에 순서를 제어하는 힌트다. from절에서 앞에 온 테이블부터 순서대로 조인한다.
  * ex) /*+ ordered use_nl(B) use_nl(C) */ *
* leading
  * 조인 할 때에 순서를 제어하는 힌트다. ordered와는 달리 힌트에서 순서를 직접제어하여, from절에 오는 테이블의 순서와 상관없이 조인 순서를 제어할 수 있다.
  * ex) /*+ leading(B, A, D, C) use_nl(A), use_nl(D) use_hash(C) */ *
* ordered나 leading이 없는 경우
  * 조인 순서를 옵티마이저가 스스로 정하도록 맡기는 경우
  * ex) /*+ use_nl(A,B,C,D) */ *

### 수행과정
* 조인 조건절의 비교 순서는 인덱스 구성에 종속된다.
  * 조인 조건절에 작성한 순서와는 상관없이 인덱스 구성 우선순위에 따라 조건절을 실행하여 인덱스를 탈 수 있도록 실행한다.
* 조인 시 조건절에 따라 인덱스 테이블을 탐색할 때, 각 조건별로 전체 데이터를 조회 후 다음 조건으로 넘어가는 것이 아닌, 한 레코드씩 순차적으로 모든 조건을 탐색하여 조인 결과를 얻은 뒤에 다음 레코드로 넘어간다는 점에 주의해야한다.

### 조인 튜닝 포인트
> NL 조인은 인덱스를 이용하여 조인을 하는 만큼 인덱스 탐색 튜닝과 매우 비슷한 튜닝 요소를 가진다.

* INNER 테이블과 OUTER 테이블의 인덱스 테이블 양쪽에 조인 조건이 포함되어 있으면 비용이 큰 블록 I/O 횟수를 줄일 수 있다.
* 다중 중첩문을 이용하여 조인이 이뤄지는 만큼 각 루프 단계에서 조회하는 레코드의 범위를 줄일 수록 불필요한 데이터 조회 횟수를 줄일 수 있다.
* 단 건 또는 소량의 레코드를 조건에 따라 자주 조회하는 OLTP 시스템에서 튜닝할 때에는 NL 조인을 이용하는 것이 좋다.
  * 만약 OLTP 환경에서 NL 조인 시애 성능이 느리다면 각 수행단계에서 과도한 랜덤 액세스가 발생하는 지점을 우선 파악하여 조인 순서를 변경하거나 더 효과적인 인덱스가 있는지 등을 먼저 검토하고, 필요한 경우 인덱스 추가 또는 구성 변경을 한다.
  * 여러 방안을 검토해도 NL 조인으로 좋은 성능을 낼 수 없다면 해시 조인이나 머지 조인을 검토한다.
  * 단! OLTP 환경의 경우 머지 조인과 해시 조인의 매커니즘 상 자주 호출 하는 OLTP 환경의 특성 상 성능에 어느정도 손해가 있더라도(생각보다 많이 차이가 나더라도) NL 조인을 이용하는 것이 좋다.

### NL 조인 확장 메커니즘
오라클은 NL 조인 성능을 높이기 위해 테이블 Prefetch, 배치 I/O 기능을 도입했다.
* Prefetch
  * 테이블 Prefetch는 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요할 때에 해당 레코드가 있는 블록 외에 뒤에 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능이다.
  * 디스크 I/O 횟수를 줄이고, 버퍼캐시에서 데이터를 바로 읽을 수 있어 조인 속도를 향상시킬 수 있다ㅏ.
* 배치 I/O
  * 배치 I/O는 이름 그대로 디스크 I/O콜을 모아서 읽어야할 블록이 일정량 쌓이면 한번에 처리하는 기능이다.
  * 한 번의 디스크 I/O에 여러 블록을 읽어 읽는 블록마다 건 단위로 I/O 콜을 발생시키는 비효율을 줄일 수 있다.

### NL 조인 특징
1. 랜덤 액세스 위주의 조인 방식
2. 한 레코드씩 순차적으로 진행
3. 인덱스 구성 전략이 특히 중요
4. OLTP 시스템에 적합함

## 소트 머지 조인
> 조인 컬럼에 인덱스가 없거나 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때, NL 조인 대신 소트 머지 조인이나 해시 조인을 사용할 수 있다.
> 해시 조인이 나오면서 쓰이는 일이 줄었지만, 해시 조인을 사용하지 못하는 경우 여전히 유용한 방법이다.

### SGA vs PGA
* SGA
  * 공유 메모리 공간으로 SGA에 캐시된 데이터는 여러 프로세스가 공유할 수 있다.
  * 동시에 액세스는 불가능하며, 동시에 액세스하려는 프로세스 간 액세스를 직렬화 하는 Lock 메커니즘으로 래치가 존재한다.
  * DB 버퍼캐시는 SGA의 핵심적인 구성요소이며, 여기서 블록을 읽으려면 버퍼 Lock도 얻어야 한다.
* PGA
  * 오라클은 SGA 외에도 서버 프로세스에 자신만의 고유 메모리 영역을 가지며 이를 PGA라고 한다.
  * PGA는 프로세스에 종속적인 고유데이터를 저장하는 용도로 사용한다.
  * PGA 공간이 작아 데이터를 모두 저장할 수 없는 경우 Temp 테이블스페이스를 사용한다.
  * PGA는 다른 프로세스와 공유하지 않아 래치 메커니즘이 필요하지 않으며, 따라서 SGA보다 훨씬 빠른 속도를 보장한다.
  * 소트머지조인과 해시조인시에 PGA를 이용한다.

### 기본 메커니즘
> 소트 머지 조인은 이름과 같이 소트 단계와 머지 단계의 두 단계로 진행한다.

1. 소트 단계
   * Inner 테이블에서 쿼리의 해당 테이블에 대한 조건에 따라 조회하여 조인컬럼 순으로 정렬하고, 정렬한 결과집합을 PGA에 저장한다. 이 때, PGA에 공간이 부족한 경우 Temp 테이블 스페이스에 저장한다.
   * Outer 테이블도 쿼리의 해당 테이블에 대한 조건에 따라 조회하여 조인컬럼 순으로 정렬하고, 정렬한 결과집합을 PGA에 저장한다. 마찬가지로 PGA 공간이 부족한 경우 Temp 테이블 스페이스에 저장한다.
2. 머지 단계
   * PGA에 저장한 Inner 테이블의 데이터를 스캔하면서 PGA에 저장한 Outer 테이블의 데이터와 조인한다.
   * 이 때, Inner 테이블의 레코드에 따라 Outer 테이블의 레코드를 찾을 때 정렬한 컬럼이 인덱스와 같이 작동하여 Range scan을 이용하여 레코드를 조회한다.

### 소트 머지 조인이 빠른 이유
> NL 조인은 대량 데이터 조인할 때 성능이 매우 느리다는 단점을 가지고 있다. 소트 머지 조인과 해시 조인이 개발된 이유다.

소트 머지 조인은 SortArea에 미리 정렬해 둔 자료구조를 이용하는 점 외에는 NL 조인과 같은 프로세싱을 사용한다.<br>
그럼에도 성능이 차이가 나는 이유는 NL 조인의 경우 조인 과정에서 엑세스 하는 모든 블록을 랜덤 액세스 방식으로 '건건이' DB 버퍼캐시를 경유해서 읽는 다는 점에 있다.<br>
NL 조인의 경우 인덱스와 테이블 모두 읽는 모든 블록에 래치 획득 및 캐시버퍼 체인 스캔 과정을 거치고, 버퍼캐시에 없는 데이터는 '건건이' 디스크에서 읽어 들인다.<br>
인덱스를 이용하기 때문에 인덱스 손익분기점 한계를 그대로 드러내게 된다. NL 조인이 대량 데이터 조인에서 불리한 이유다.<br>
반면, 소트 머지 조인은 양쪽 테이블의 조인 대상 집합을 모두 읽어 PGA에 저장한 후 조인한다. PGA는 해당 프로세스만을 위한 독립적 공간이므로 래치 획득 과정이 없다. 소트 머지조인이 대량 데이터 조인에 유리한 이유다.<br>
정렬로 인한 비용 발생으로 NL 조인보다 느릴 것 같지만, 정렬을 하고 PGA에 모두 올려두기 때문에 대량 데이터 조인에서 NL 조인보다 유리하다.<br>
소트 머지 조인도 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경유하며, 이때 인덱스를 이용하기도 한다. 이 과정에서 생기는 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 소트 머지 조인도 동일하다.

### 소트 머지 조인의 주용도
> 해시 조인의 등장으로 소트 머지 조인은 대량 데이터 조인에서도 해시 조인에 자리를 내어줄 수 밖에 없었다. 그럼에도 소트 머지 조인이 사라지지 않은 것은 해시 조인의 경우 조인 조건식이 등치 조건인 경우에만 사용가능하기 때문이다.

아래의 경우 소트 머지 조인을 사용한다.
* 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
* 조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)

### 소트 머지 조인 제어
* use_merge 힌트를 사용하여 소트 머지 사용을 지시한다.

## 해시 조인
> 해시 조인은 정렬에 대한 부담이 없어 소트 머지 조인보다 더 좋은 성능을 보장한다. 하지만 모든 조인을 해시 조인으로 처리할 수 없으므로, 상황에 맞게 조인 방법을 선택해야 한다.

### 기본 메커니즘
1. Build 단계
   * Inner 테이블을 쿼리 내의 조건문에 따라 읽어 해시 테이블을 생성한다. 이 때, 조인컬럼을 해시 테이블 키 값으로 사용한다.
   * 조인컬럼을 해시함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인에 데이터를 연결한다.
   * 해시 테이블은 Hash Area에 저장하며, 해시 테이블이 너무 커 PGA에 담을 수 없으면 Temp 테이블스페이스에 저장한다.
2. Probe 단계
   * Outer 테이블을 쿼리 내의 조건문에 따라 읽어 Build 단계에서 생성한 해시테이블을 탐색한다.
   * 조인컬럼을 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인을 스캔해서 값이 같은 데이터를 찾는다.
   * 해시 함수는 Build 단계에서 사용한 해시 함수를 동일하게 사용하여 같은 값을 입력했을 때 동일한 결과값을 같는다.

### 해시 조인이 빠른 이유
1. PGA 영역 사용
   * 소트 머지 조인이 빠른 이유와 동일하게 래치 획득 과정이 필요 없다.
2. 정렬이 필요 없으며, 작은 테이블의 해시맵만 생성
   * 소트 머지 조인과는 다르게 양 테이블을 정렬할 필요가 없다.
   * 두 집합 중 작은 집합의 해시 맵만 작성하여 해시 테이블을 생성하여 PGA 내에만 데이터를 올릴 확률이 높아져 속도가 더 빠르며, Temp 테이블스페이스를 이용하더라도 일반적으로 해시 조인이 가장 빠르다.

### 대용량 Build Input 처리
<img alt="해시 조인 대용량 Build Input 처리 시 Partitioning" src="https://github.com/Ariel-92/Ariel-92.github.io/assets/71688847/f0fc8010-cfbd-44a0-b01e-654346a25fd7">
두 테이블 모두 대용량 테이블이어서 인메모리 해시 조인이 불가능한 경우 DBMS는 분할&정복(Divide & Conquer) 방식을 이용하여 처리한다.

1. 파티션 단계
   * 조인하는 양쪽 집합(조인 이외 조건절을 만족하는 레코드)의 조인 컬럼에 해시함수를 적용하고, 반환된 해시 값에 따라 동적으로 파티셔닝하여, 여러개의 서브 집합으로 판할해 파티션 짝을 생성한다.
   * 양쪽 집합을 읽어 디스크 Temp 공간에 저장해야 하므로 인메모리 해시 조인 보다 성능이 많이 떨어진다.
2. 조인 단계
   * 각 파티션 짝에 대해 하나씩 조인을 수행한다.
   * 이 때, 각각에 대한 Build Input과 Prove Input은 독립적으로 결정하며, 기존의 테이블을 무시하고 작은 쪽을 Build Input으로 선택한다.
   * 해시 테이블을 생성하고 나면 기존의 Prove 단계와 같이 반대쪽 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색하며, 모든 파티션 짝에 대한 처리를 할 때까지 반복한다.

### 해시 조인 실행계획 제어
* use_hash 힌트를 사용하여 해시 조인 사용을 지시할 수 있다.
* leading 또는 ordered 힌트를 이용하여 조인 순서를 지시해 Build Input을 사용자가 지정할 수 있다.
* swap_join_inputs, no_swap_join_inputs 힌트로 Build Input을 명시적으로 선택할 수 있다.

### 조인 메소드 선택 기준
일반 적인 경우 아래의 선택 기준을 따른다. 이 때 대량 의 기준은 NL 조인으로 최적화를 했음에도 랜덤 액세스가 많아 원하는 성능을 낼 수 없는 경우를 말한다.
* 소량 데이터를 조인하는 경우 => NL 조인
* 대량 데이터를 조인하는 경우 => 해시 조인
* 대량 데이터 조인인데 해시 조인으로 처리할 수 없는 경우(조인 조건절이 등치가 아닌 경우) => 소트 머지 조인

수행 빈도가 매우 높은 경우에는 아래의 조건을 추가적으로 고려하는 것이 좋다.
* (최적화된) NL 조인과 해시 조인 성능이 같은경우 => NL 조인
* 해시 조인이 약간 더 빠른 경우 => NL 조인
* NL 조인보다 해시 조인이 매우 빠를 경우 => 해시 조인

마지막 조건의 경우는 대량 데이터 조인일 것이므로 일반 적인 경우의 대량 데이터 조인과 의미가 같다고 볼 수 있다.

### 조인메소드를 선택할 때 NL 조인을 우선적으로 고려하는 이유
NL 조인에서 사용하는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조다.<br>
그에 반해 PGA를 사용하는 해시 조인과 소트 머지 조인의 경우 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 삭제하는 데이터로, CPU 자원과 메모리 공간을 차지하며 Hash Map을 생성하거나 Sort 하는 과정에서 래치 경합이 발생할 수 있다.<br>
그러므로 해시 조인이 NL 조인보다 어느정도 빠르더라도 호출 빈도가 높은 경우에는 해시 조인이 서버 환경에 지나친 부담을 줄 수 있어 NL 조인을 사용하는 것이 좋다.

## 서브쿼리 조인
> 실무에서는 단순한 형태의 조인 뿐만 아닌 복잡한 서브쿼리와 조인하는 형태도 흔히 볼 수 있다.

### 서브쿼리 변환이 필요한 이유
같은 결과집합을 얻는 과정에서도 SQL을 다양한 형태로 표현할 수 있고, 어떤 것을 선택하느냐에 따라 성능에 차이가 있을 수 있다.
최근 옵티마잊저는 비용을 평가하고 실행계획을 생성하기에 앞서 전달 받은 SQL을 최적화에 유리한 작업, 즉 쿼리 변환부터 진행한다.
쿼리 변환은 옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것을 말한다.<br>
서브쿼리는 하나의 SQL문 안에 괄호로 묶은 별도의 쿼리 블록을 말한다. DBMS에 따라 조금씩 분류가 다르나, 오라클 기준으로는 아래 세가지로 분류한다.
1. 인라인 뷰(Inline View) : FROM 절에 사용한 서브쿼리를 말한다.
2. 중첩된 서브쿼리(Nested Subquery) : 결과집합을 한정하기 위해 WHERE 절에 사용한 서브쿼리다. 메인쿼리의 컬럼을 잠조하는 형태는 '상관관계 있는(Correlated) 서브쿼리'라고 부른다.
3. 스칼라 서브쿼리 : 한 레코드 당 정확히 하나의 값을 반환하는 서브쿼리다.

전체적인 성능을 최적화 함에 있어 서브쿼리의 최적화는 중요하다. 특히, 서브쿼리 별 각자의 최적화도 중요하지만, 전체 쿼리의 흐름에 따라 맞물리는 최적화를 할 수 있도록 해야한다.

### 서브쿼리와 조인
메인쿼리와 서브쿼리는 종속적이고 계층적인 관계로 되어있다. 서브쿼리는 메인쿼리에 종속되어 단독으로 실행이 불가능하다.

#### 필터 오퍼레이션
필터 오퍼레이션은 기본적으로 NL 조인과 동일한 처리 루틴을 가진다. 다만 NL 조인과는 달리 조인에 성공한 로우가 나오면 진행을 멈추고 메인쿼리의 다음 로우로 넘어간다.
메인쿼리의 결과집합이 의도하지 않게 범위가 확장되는 것을 막기 위함이다. 또한 필터 오퍼레이션 시에는 캐싱 기능을 사용하여 성능을 높일 수 있으며, 일반 NL 조인과 달리 메인쿼리에 종속되므로 조인 순서가 고정된다.<br>
필터 오퍼레이션을 사용할 때는 no_unnest 힌트를 사용하여 서브쿼리를 풀어내지 말고 그대로 사용하도록 해야한다.

#### 서브쿼리 Unnesting
unnest 힌트를 사용하여 명시적으로 적용할 수 있다. 다만, 대부분의 경우 옵티마이저는 기본적으로 Unnesting을 선택한다.<br>
Unnesting을 사용하는 경우 메인쿼리와 서브쿼리의 계층관계를 무시하고 동일레벨로 조정하여 일반 조인문과 같이 조인을 수행한다. 이 때 NL 세미조인, HASH 세미조인 과 같이 기존 조인 방법과 같은 절차를 수행하지만 첫번째 조인 성공이 이뤄지면 중단하고 다음 메인쿼리의 로우를 처리하는 조인 방식을 사용한다.

#### 서브쿼리 Pushing
Unnesting을 하지 않는 경우 서브쿼리는 항상 필터 방식으로 처리되며, 대게 실행계획 상에서 마지막 단계에 처리한다. 
때로는 이로 인해 메인 쿼리의 조인 과정에서 필요이상의 데이터를 조회하고, 조회한 데이터 위에서 소수의 데이터를 결과값으로 갖는 서브쿼리 필터링이 수행되는 경우가 발생한다.
이런 경우에 서브쿼리 필터링을 먼저 수행하게 되면 메인 쿼리에서 조인 과정에서 조회하는 데이터가 줄어 성능 향상에 도움이 되는데, 이렇게 서브쿼리 필터링을 먼저 수행하는 것을 서브쿼리 Pushing이라고 하며, push_subq 힌트를 사용하여 지시할 수 있다.<br>
Pushing 서브쿼리를 사용하게되면 서브쿼리 필터링을 가능한 한 앞 단계에서 처리하도록 강제하며, 이 기능은 Unnesting 되지 않은 서브쿼리 에만 작동한다는 점에 주의해야한다.

### 뷰와 조인
최적화 단위가 쿼리 블록이므로 옵티마이저가 뷰 쿼리를 변환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화 환다.
그런데 이 때에 뷰 쿼리에서 조회한 데이터의 범위 조건이 뷰 쿼리 바깥의 메인 쿼리에 있는 경우에 문제가 발생한다. 
뷰 쿼리 내에는 범위 조건이 없으므로 전체 데이터를 조회하는데, 실제로 사용하는 데이터는 그 중 일부 뿐이다.<br>
이런 경우 merge 힌트를 사용하여 메인쿼리와 뷰 쿼리를 머징하여 조인하도록 할 수 있다.
변환된 쿼리는 양쪽 테이블을 조인하고 문제가 됐던 조건문이 적절하게 적용하도록 할 수 있다.<br>
단점은 서브 쿼리 내에 group by 등이 있는 경우 성공한 전체 집합을 group by 하고 나서 데이터를 출력할 수 있다는 점이다.
즉, 부분범위 처리가 불가능하다. 만약 양쪽의 데이터가 모두 많다면 이런 경우에는 NL 조인보다 HASH 조인이 유리할 수 있다.

#### 조인 조건 Pushdown
조인 조건 Pushdown이란 메인 쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어 넣는 기능이다. 건건이 데이터를 읽어서 조인하기 때문에 부분범위 처리가 가능하다.<br>
push_pred 힌트를 사용하여 제어할 수 있으며, no_merge 힌트와 함께 사용하는 것이 안전하다.

### 스칼라 서브쿼리 조인
1. 스칼라 서브쿼리의 특징
   * 스칼라 서브쿼리는 메인쿼리 레코드마다 정확히 하나의 값만 반환한다.
   * 스칼라 서브쿼리는 처리과정에서 캐싱 작용이 일어난다.
2. 스칼라 서브쿼리 캐싱 효과
   * 오라클은 조인 횟수를 최소화하기 위해 입력 값과 출력 값을 내부 캐시에 저장해둔다. 조인할 때 동일한 입력값이 캐시에 있는 경우 캐시에서 확인한 결과값을 바로 반환하고, 없는 경우에만 조인을 수행한다.
   * 캐싱은 조인 성능을 높이는데 도움이 된다.
3. 스칼라 서브쿼리 부작용
   * 캐시 공간은 작은 공간이기 때문에 많은 공간을 할당하기 어렵다.
   * 그렇기 때문에 스칼라 서브쿼리는 결과값이 소수여서 해시 충돌이 작은 경우에 효과가 있다. 반대의 경우 캐시를 매번 확인하는 비용 때문에 되려 성능이 저하되고 자원을 더 소비할 수 있다.
   * 메인쿼리 집합이 작은 경우 캐시에 저장한 데이터를 재사용할 확률이 낮아져 효용성이 떨어질 수 있다.
4. 두 개 이상의 값 반환
   * 구하는 값을 문자열로 모두 결합하고, 바깥쪽 액세스 쿼리에서 substr 함수로 다시 분할하는 방법이 있다.
   * 오브젝트 TYPE을 사용하는 방법도 있으나, TYPE을 미리 선언해야하는 불편함으로 인해 잘 쓰이지 않는다.
   * 인라인 뷰를 사용하는 방법이 있다. 조인 조건 Pushdown 기능이 적용되면서 더 유용하게 사용가능한 방법이 되었다.
5. 스칼라 서브쿼리 Unnesting
   * NL 방식으로 조인하기 때문에 캐싱 효과가 크지 안으면 I/O 부담이 있다.
   * 병렬 쿼리와 같이 해시 조인으로 처리하는게 유리한 경우에는 그대로 사용할 수 없어 Unnesting을 해야 한다.
